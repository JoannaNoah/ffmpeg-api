import os
import subprocess
import uuid
import json
import logging
import shlex
import shutil
from flask import Flask, request, jsonify
import boto3
from botocore.client import Config
import requests
from functools import wraps

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

app = Flask(__name__)

R2_ENDPOINT_URL = os.environ.get('R2_S3_ENDPOINT')
R2_ACCESS_KEY_ID = os.environ.get('R2_ACCESS_KEY_ID')
R2_SECRET_ACCESS_KEY = os.environ.get('R2_SECRET_ACCESS_KEY')
R2_BUCKET_NAME = os.environ.get('R2_BUCKET_NAME')
R2_PUBLIC_DOMAIN = os.environ.get('R2_PUBLIC_DOMAIN')
API_KEY = os.environ.get('FFMPEG_API_KEY')

s3 = boto3.client(
    's3',
    endpoint_url=R2_ENDPOINT_URL,
    aws_access_key_id=R2_ACCESS_KEY_ID,
    aws_secret_access_key=R2_SECRET_ACCESS_KEY,
    config=Config(signature_version='s3v4')
)

def require_api_key(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not API_KEY:
            logging.error("API_KEY is not configured on the server.")
            return jsonify({"error": "Server configuration error"}), 500
        
        provided_key = request.headers.get('X-API-Key')
        if not provided_key or provided_key != API_KEY:
            return jsonify({"error": "Unauthorized"}), 401
        return f(*args, **kwargs)
    return decorated_function

def download_file(url, target_path):
    try:
        with requests.get(url, stream=True, timeout=300) as r:
            r.raise_for_status()
            with open(target_path, 'wb') as f:
                for chunk in r.iter_content(chunk_size=8192):
                    f.write(chunk)
    except requests.exceptions.RequestException as e:
        raise Exception(f"Failed to download {url}: {e}")

@app.route('/process', methods=['POST'])
@require_api_key
def process_media():
    data = request.json
    task_id = str(uuid.uuid4())
    logging.info(f"Starting task: {task_id}")

    input_urls = data.get('input_urls', [])
    command_template = data.get('command')
    output_path = data.get('output_path', '')
    output_extension = data.get('output_extension', 'mp4')

    if not command_template or not isinstance(input_urls, list) or not input_urls:
        return jsonify({"error": "Missing 'command' or 'input_urls' must be a non-empty list"}), 400

    for url in input_urls:
        if not url.startswith(('http://', 'https://')):
            return jsonify({"error": f"Invalid URL format: {url}"}), 400

    temp_dir = f"/tmp/{task_id}"
    os.makedirs(temp_dir, exist_ok=True)
    
    input_files = []
    
    try:
        for i, url in enumerate(input_urls):
            extension = os.path.splitext(url.split('?')[0])[-1] or '.tmp'
            input_filename = f"{temp_dir}/input_{i}{extension}"
            download_file(url, input_filename)
            input_files.append(input_filename)

        if 'concat_list.txt' in command_template:
            concat_list_path = os.path.join(temp_dir, "concat_list.txt")
            with open(concat_list_path, 'w') as f:
                for file_path in input_files:
                    f.write(f"file '{os.path.basename(file_path)}'\n")
            command_template = command_template.replace('concat_list.txt', concat_list_path)

        output_filename = os.path.join(temp_dir, f"output.{output_extension}")

        format_dict = {f'input_{i}': path for i, path in enumerate(input_files)}
        format_dict['output'] = output_filename
        if len(input_files) == 1:
            format_dict['input'] = input_files[0]
            
        command = command_template.format(**format_dict)
        logging.info(f"Executing command for task {task_id}: {command}")
        
        command_list = shlex.split(command)
        
        result = subprocess.run(
            command_list, 
            check=True, 
            capture_output=True, 
            text=True, 
            timeout=900,
            cwd=temp_dir
        )

        if "ffprobe" in command.lower():
            logging.info(f"Task {task_id} (ffprobe) completed successfully.")
            return jsonify({"status": "success", "output": result.stdout.strip()})

        s3_object_name = output_path.lstrip('/') if output_path else f"processed/{task_id}.{output_extension}"
        s3.upload_file(output_filename, R2_BUCKET_NAME, s3_object_name, ExtraArgs={'ContentType': f'video/{output_extension}'})
        
        if not R2_PUBLIC_DOMAIN:
             logging.error("R2_PUBLIC_DOMAIN environment variable is not set.")
             return jsonify({"error": "Server configuration error: R2 public domain not set."}), 500

        final_output_url = f"{R2_PUBLIC_DOMAIN.rstrip('/')}/{s3_object_name}"
        logging.info(f"Task {task_id} completed successfully. Output URL: {final_output_url}")
        return jsonify({"status": "success", "output_url": final_output_url})

    except subprocess.TimeoutExpired:
        logging.error(f"Task {task_id} timed out.")
        return jsonify({"error": "Processing timed out"}), 500
    except subprocess.CalledProcessError as e:
        logging.error(f"Task {task_id} failed. Stderr: {e.stderr.strip()}")
        return jsonify({"error": "FFmpeg/FFprobe command failed", "stderr": e.stderr.strip()}), 500
    except Exception as e:
        logging.error(f"Task {task_id} failed with an internal error: {str(e)}")
        return jsonify({"error": "An internal error occurred", "details": str(e)}), 500
    finally:
        if os.path.exists(temp_dir):
            shutil.rmtree(temp_dir)

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=int(os.environ.get('PORT', 8080)))
